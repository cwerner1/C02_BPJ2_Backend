package com.flattery;

import com.fasterxml.jackson.databind.JsonNode;
import com.flattery.models.User;
import com.flattery.repositories.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.Optional;
import java.util.stream.Stream;

@RestController    // This means that this class is a Controller
@RequestMapping(path = "/user") // This means URL's start with /demo (after Application path)
@CrossOrigin(origins = "http://localhost:8100")
public class UserController extends BaseController {
    // Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    UserRepository userRepository;

    // TODO: Load from a configuration file.
    private static final int BCRYPT_DEFAULT_COST = 12;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * Registers a new user with a name and password.
     *
     * @return Status
     */
    @PostMapping(path = "/register")
    public @ResponseBody
    String registerUser(@RequestBody String payload) throws IOException {
        JsonNode a = this._JSONParse(payload);
        String email = a.get("email").asText();
        String password = a.get("password").asText();
        if (userRepository.findAllByEmail(email).isPresent()) {
            return getError("User Exists");
        }
        User user = new User();
        user.setEmail(email);
        user.setPassword(_hashPassword(password));
        userRepository.save(user);
        return "{ \"success\": true, \"data\":{\"id\": " + user.getId() + ",\"access_token\":" + String.valueOf(user.getId()) + "," +
                "\"expires_in\": 3600" +
                "}}";
        // @TODO  return getResponse();
    }


    /**
     * Generates a hashed and salted password for the User.
     *
     * @param plainTextPassword User supplied password in plaintext.
     * @return Hashed and salted password.
     */
    private String _hashPassword(String plainTextPassword) {
        return BCrypt.hashpw(plainTextPassword, BCrypt.gensalt(BCRYPT_DEFAULT_COST));
    }


    /**
     * Verifies if the supplied password by the User matches the salted hash.
     *
     * @param candidatePassword the password to test
     * @param hashedPassword    the hashed User Password
     * @return true if the Password matches
     */

    public boolean verifyPassword(String candidatePassword, String hashedPassword) {
        return BCrypt.checkpw(candidatePassword, hashedPassword);
    }

    @PostMapping(path = "/login") // Map ONLY GET Requests
    public @ResponseBody
    String loginUser(@RequestBody String payload) throws IOException {
        System.out.println(payload);
        JsonNode a = this._JSONParse(payload);
        String email = a.get("email").asText();
        String password = a.get("password").asText();
        Optional<User> possibleUsers = userRepository.findAllByEmail(email);

        if (!possibleUsers.isPresent()) {
            System.out.println("nouser");
            return getError("User Exisitiert nicht");

        }
        User possibleUser = possibleUsers.get();
        System.out.println(possibleUser);
        if (this.verifyPassword(password, possibleUser.getPassword())) {
            System.out.println("hasUser");

            return "{ \"success\": true, \"data\":{\"id\": " + possibleUser.getId() + ",\"access_token\":" + String.valueOf(possibleUser.getId()) + "," +
                    "\"expires_in\": 3600" +
                    "}}";
            // @TODO  return getResponse();
        }
        System.out.println("error");
        return getError();
    }

    @GetMapping(path = "/getByUserID/{str_id}")
    public @ResponseBody
    String getUserDetail(@PathVariable String str_id) {

        Integer id = Integer.parseInt(str_id);

        Optional<User> wohnungOptional = userRepository.findById(id);
        if (!wohnungOptional.isPresent()) {

            return getError("Dieser User existiert nicht.");
        }
        User user = wohnungOptional.get();
        setData(user);

        return getResponse();
    }


}
