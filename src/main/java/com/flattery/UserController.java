package com.flattery;

import com.fasterxml.jackson.databind.JsonNode;
import com.flattery.models.User;
import com.flattery.repositories.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@RestController    // This means that this class is a Controller
@RequestMapping(path = "/user") // This means URL's start with /demo (after Application path)
@CrossOrigin(origins = "http://localhost:8100")
public class UserController extends BaseController {
    // Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    UserRepository userRepository;

    // TODO: Load from a configuration file.
    private static final int BCRYPT_DEFAULT_COST = 12;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * Registers a new user with a name and password.
     *
     * @return Status
     */
    @PostMapping(path = "/register")
    public @ResponseBody
    String registerUser(@RequestBody String payload) throws IOException {
        JsonNode a = this._JSONParse(payload);

        if (!_isReceived(a,"email")) {
            return getError("Die E-Mail fehlt.");
        }
        if (!_isReceived(a,"password")) {
            return getError("Das Passwort fehlt.");
        }

        String email = a.get("email").asText();
        String password = a.get("password").asText();
        if (userRepository.findAllByEmail(email).isPresent()) {
            return getError("Der Benutzer existiert schon.");
        }
        User user = new User();
        user.setEmail(email);
        user.setPassword(_hashPassword(password));
        userRepository.save(user);

        Map<String, Object> data = new HashMap<>();
        data.put("id", user.getId());
        data.put("access_token", Integer.toString(user.getId()));
        data.put("expires_in", 3600);
        setData(data);

        return getResponse();
    }


    /**
     * Generates a hashed and salted password for the User.
     *
     * @param plainTextPassword User supplied password in plaintext.
     * @return Hashed and salted password.
     */
    private String _hashPassword(String plainTextPassword) {
        return BCrypt.hashpw(plainTextPassword, BCrypt.gensalt(BCRYPT_DEFAULT_COST));
    }


    /**
     * Verifies if the supplied password by the User matches the salted hash.
     *
     * @param candidatePassword the password to test
     * @param hashedPassword    the hashed User Password
     * @return true if the Password matches
     */

    public boolean verifyPassword(String candidatePassword, String hashedPassword) {
        return BCrypt.checkpw(candidatePassword, hashedPassword);
    }

    @PostMapping(path = "/login") // Map ONLY GET Requests
    public @ResponseBody
    String loginUser(@RequestBody String payload) throws IOException {
        JsonNode a = this._JSONParse(payload);

        if (!_isReceived(a,"email")) {
            return getError("Die E-Mail fehlt.");
        }
        if (!_isReceived(a,"password")) {
            return getError("Das Passwort fehlt..");
        }

        String email = a.get("email").asText();
        String password = a.get("password").asText();
        Optional<User> possibleUsers = userRepository.findAllByEmail(email);

        if (!possibleUsers.isPresent()) {
            System.out.println("nouser");
            return getError("Der Benutzer existiert nicht");

        }
        User possibleUser = possibleUsers.get();
        System.out.println(possibleUser);
        if (this.verifyPassword(password, possibleUser.getPassword())) {
            System.out.println("hasUser");

            Map<String, Object> data = new HashMap<>();
            data.put("id", possibleUser.getId());
            data.put("access_token", Integer.toString(possibleUser.getId()));
            data.put("expires_in", 3600);
            setData(data);

            return getResponse();
        }
        System.out.println("error");
        return getError();
    }

    @GetMapping(path = "/getByUserID/{str_id}")
    public @ResponseBody
    String getUserDetail(@PathVariable String str_id) {

        Integer id = Integer.parseInt(str_id);

        Optional<User> wohnungOptional = userRepository.findById(id);
        if (!wohnungOptional.isPresent()) {

            return getError("Dieser Benutzer existiert nicht.");
        }
        User user = wohnungOptional.get();
        setData(user);

        return getResponse();
    }


}
